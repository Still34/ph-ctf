using System;
using System.Buffers.Binary;
using System.IO;
using System.Net.Sockets;
using System.Security.Cryptography;
using System.Text;
using System.Text.Json;
using System.Threading;
using System.Threading.Tasks;

namespace MalwareC2TrafficPoC
{
    internal class Program
    {
        private readonly Guid _guid = Guid.NewGuid();
        private readonly Random _random = new Random();
        private readonly RNGCryptoServiceProvider _rngCryptoServiceProvider = new RNGCryptoServiceProvider();
        private TcpClient _tcpClient;
        private NetworkStream _networkStream;
        
        private const string TargetHost = "localhost";
        private const int TargetPort = 433;
        private static void Main(string[] args)
        {
            var program = new Program();
            var timer = new Timer(_ => program.TimerCallback(null), null, TimeSpan.Zero,
                TimeSpan.FromSeconds(10));
            Task.Delay(-1).GetAwaiter().GetResult();
        }

        public void TimerCallback(object? state)
        {
            if (state == null) throw new ArgumentNullException(nameof(state));

            _tcpClient ??= new TcpClient(TargetHost, TargetPort);

            Span<byte> byteBuffer = stackalloc byte[4];
            _rngCryptoServiceProvider.GetBytes(byteBuffer);
            var data = new C2Data
            {
                ComputerName = Environment.MachineName, 
                Username = Environment.UserName,
                Guid = _guid.ToString("D")
            };
            if (_random.Next(1, 10) % 2 == 0)
            {
                //Console.WriteLine("Sending flag...");
                data.Description = "flag{b451c_m4lw4r3_c2_7r4ff1c}";
            }
            else
            {
                Span<byte> dataBuffer = stackalloc byte[_random.Next(16, 128)];
                _rngCryptoServiceProvider.GetBytes(dataBuffer);
                data.Description = Encoding.UTF8.GetString(dataBuffer);
            }

            var trafficInternalData = JsonSerializer.SerializeToUtf8Bytes(data);
            var trafficData = new TrafficData(byteBuffer.ToArray(), trafficInternalData.Length, trafficInternalData);
            byteBuffer.Clear();

            var key = trafficData.Key;
            Console.WriteLine($"Key: {ByteArrayToString(key)}");
            var rawLength = trafficData.Length;
            Console.WriteLine($"Length: {rawLength}");
            BinaryPrimitives.WriteInt32BigEndian(byteBuffer, rawLength);
            Span<byte> newLengthHeader = stackalloc byte[4];
            for (var i = 0; i < key.Length; i++) 
                newLengthHeader[i] = (byte) (key[i % key.Length] ^ byteBuffer[i]);

            Span<byte> newData = stackalloc byte[trafficData.Length];
            for (var i = 0; i < trafficData.Length; i++)
                newData[i] = (byte) (key[i % key.Length] ^ trafficData.Data[i]);
            Span<byte> finalBuffer = stackalloc byte[key.Length + newLengthHeader.Length + newData.Length];
            var ms = new MemoryStream();
            ms.Write(key);
            ms.Write(newLengthHeader);
            ms.Write(newData);
            ms.Seek(0, SeekOrigin.Begin);
            ms.Read(finalBuffer);

            _networkStream ??= _tcpClient.GetStream();
            _networkStream.Write(finalBuffer);
        }

        public static string ByteArrayToString(byte[] ba)
        {
            var hex = new StringBuilder(ba.Length * 2);
            foreach (var b in ba)
                hex.AppendFormat("{0:x2}", b);
            return hex.ToString();
        }
    }
}